#include <TinyGPS++.h>
#include <SoftwareSerial.h>

// Enable debug mode (uncomment for detailed serial output)
#define DEBUG

#ifdef DEBUG
  #define DEBUG_PRINT(x) Serial.print(x)
  #define DEBUG_PRINTLN(x) Serial.println(x)
#else
  #define DEBUG_PRINT(x)
  #define DEBUG_PRINTLN(x)
#endif

// GPS Module (NEO-M8N)
TinyGPSPlus gps;
#define GPS_SERIAL Serial1  // TX1=18, RX1=19

// HC-12 Wireless
#define HC12_SERIAL Serial2 // TX2=16, RX2=17

// Motor Control (L293D)
const int ENA = 12;  // PWM Left
const int ENB = 13;  // PWM Right
const int motorPin1 = 8;   // Left Dir1
const int motorPin2 = 9;   // Left Dir2
const int motorPin3 = 11;  // Right Dir1
const int motorPin4 = 10;  // Right Dir2

// System Parameters
const unsigned long MOTOR_TIMEOUT_MS = 1000;  // Safety timeout
unsigned long lastCommandTime = 0;
unsigned long lastHCTestTime = 0;
bool hc12Active = false;

void setup() {
  #ifdef DEBUG
  Serial.begin(9600);
  while (!Serial);
  DEBUG_PRINTLN("System Initializing...");
  #endif

  GPS_SERIAL.begin(9600);
  HC12_SERIAL.begin(9600);

  // Initialize motor pins
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(motorPin1, OUTPUT);
  pinMode(motorPin2, OUTPUT);
  pinMode(motorPin3, OUTPUT);
  pinMode(motorPin4, OUTPUT);
  
  stopMotors();
  
  // HC-12 connection test
  HC12_SERIAL.println("HC12_TEST"); 
  lastHCTestTime = millis();
  
  DEBUG_PRINTLN("Initialization Complete");
}

void loop() {
  // 1. HC-12 Connection Check
  if (!hc12Active && millis() - lastHCTestTime > 2000) {
    HC12_SERIAL.println("HC12_TEST");
    lastHCTestTime = millis();
    DEBUG_PRINTLN("Sent HC-12 test ping");
  }

  // 2. GPS Data Handling
  while (GPS_SERIAL.available() > 0) {
    char c = GPS_SERIAL.read();
    #ifdef DEBUG
    // Serial.write(c);  // Uncomment to see raw GPS data
    #endif
    if (gps.encode(c)) {
      if (gps.location.isValid() && gps.location.isUpdated()) {
        // Send data to MATLAB: lat,lng,heading
        HC12_SERIAL.print(gps.location.lat(), 9);
        HC12_SERIAL.print(",");
        HC12_SERIAL.print(gps.location.lng(), 9);
        HC12_SERIAL.print(",");
        HC12_SERIAL.println(gps.course.isValid() ? gps.course.deg() : 0.0);
        
        #ifdef DEBUG
        DEBUG_PRINT("Position: ");
        DEBUG_PRINT(gps.location.lat(), 9);
        DEBUG_PRINT(", ");
        DEBUG_PRINT(gps.location.lng(), 9);
        DEBUG_PRINT(", Heading: ");
        DEBUG_PRINTLN(gps.course.isValid() ? gps.course.deg() : 0.0);
        #endif
        
        hc12Active = true;  // Mark HC-12 as active
      }
    }
  }

  // 3. Motor Command Handling
  if (HC12_SERIAL.available() > 0) {
    String command = HC12_SERIAL.readStringUntil('\n');
    command.trim();
    
    // Check for HC-12 test response
    if (command == "HC12_ACK") {
      hc12Active = true;
      DEBUG_PRINTLN("HC-12 connection confirmed");
      return;
    }
    
    int comma1 = command.indexOf(',');
    int comma2 = command.indexOf(',', comma1 + 1);
    
    if (comma1 > 0 && comma2 > comma1) {
      lastCommandTime = millis();
      
      int pwm_left = command.substring(0, comma1).toInt();
      int pwm_right = command.substring(comma1 + 1, comma2).toInt();
      int waypointReached = command.substring(comma2 + 1).toInt();

      setMotorSpeeds(pwm_left, pwm_right);
      
      #ifdef DEBUG
      DEBUG_PRINT("Motor Cmd: L=");
      DEBUG_PRINT(pwm_left);
      DEBUG_PRINT(" R=");
      DEBUG_PRINT(pwm_right);
      DEBUG_PRINT(" WP=");
      DEBUG_PRINTLN(waypointReached);
      #endif
    }
  }

  // 4. Safety Check
  if (millis() - lastCommandTime > MOTOR_TIMEOUT_MS) {
    stopMotors();
    #ifdef DEBUG
    static unsigned long lastWarning = 0;
    if (millis() - lastWarning > 2000) {
      lastWarning = millis();
      DEBUG_PRINTLN("WARNING: Motor timeout - No commands received");
    }
    #endif
  }
}

void setMotorSpeeds(int left, int right) {
  left = constrain(left, -255, 255);
  right = constrain(right, -255, 255);

  // Left Motor
  digitalWrite(motorPin1, left > 0 ? HIGH : LOW);
  digitalWrite(motorPin2, left > 0 ? LOW : HIGH);
  analogWrite(ENA, abs(left));

  // Right Motor
  digitalWrite(motorPin3, right > 0 ? HIGH : LOW);
  digitalWrite(motorPin4, right > 0 ? LOW : HIGH);
  analogWrite(ENB, abs(right));
}

void stopMotors() {
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  digitalWrite(motorPin1, LOW);
  digitalWrite(motorPin2, LOW);
  digitalWrite(motorPin3, LOW);
  digitalWrite(motorPin4, LOW);
}
